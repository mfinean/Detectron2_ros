#!/usr/bin/env python2.7
import sys
import threading
import time

import cv2 as cv
import numpy as np
import rospy
import tf2_ros as tf2

from visualization_msgs.msg import Marker
from geometry_msgs.msg import TransformStamped
import tf.transformations as transformations


from geometry_msgs.msg import Point
from geometry_msgs.msg import Pose
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import Transform
from geometry_msgs.msg import TransformStamped
from geometry_msgs.msg import Vector3
from geometry_msgs.msg import PointStamped

# from detectron2_ros.msg import PersonPositions, PersonPosition
from finean_msgs.msg import PersonPositions, PersonPosition

# For sync depth and rgb
import message_filters


def pose_to_pq(msg):
    """Convert a C{geometry_msgs/Pose} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    p = np.array([msg.position.x, msg.position.y, msg.position.z])
    q = np.array([msg.orientation.x, msg.orientation.y,
                  msg.orientation.z, msg.orientation.w])
    return p, q


def pose_stamped_to_pq(msg):
    """Convert a C{geometry_msgs/PoseStamped} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    return pose_to_pq(msg.pose)


def transform_to_pq(msg):
    """Convert a C{geometry_msgs/Transform} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    p = np.array([msg.translation.x, msg.translation.y, msg.translation.z])
    q = np.array([msg.rotation.x, msg.rotation.y,
                  msg.rotation.z, msg.rotation.w])
    return p, q


def transform_stamped_to_pq(msg):
    """Convert a C{geometry_msgs/TransformStamped} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    return transform_to_pq(msg.transform)


def msg_to_se3(msg):
    """Conversion from geometric ROS messages into SE(3)

    @param msg: Message to transform. Acceptable types - C{geometry_msgs/Pose}, C{geometry_msgs/PoseStamped},
    C{geometry_msgs/Transform}, or C{geometry_msgs/TransformStamped}
    @return: a 4x4 SE(3) matrix as a numpy array
    @note: Throws TypeError if we receive an incorrect type.
    """
    if isinstance(msg, Pose):
        p, q = pose_to_pq(msg)
    elif isinstance(msg, PoseStamped):
        p, q = pose_stamped_to_pq(msg)
    elif isinstance(msg, Transform):
        p, q = transform_to_pq(msg)
    elif isinstance(msg, TransformStamped):
        p, q = transform_stamped_to_pq(msg)
    else:
        raise TypeError("Invalid type for conversion to SE(3)")
    norm = np.linalg.norm(q)
    if np.abs(norm - 1.0) > 1e-3:
        raise ValueError(
            "Received un-normalized quaternion (q = {0:s} ||q|| = {1:3.6f})".format(
                str(q), np.linalg.norm(q)))
    elif np.abs(norm - 1.0) > 1e-6:
        q = q / norm
    g = transformations.quaternion_matrix(q)
    g[0:3, -1] = p
    return g

class PersonPublisher(object):
    def __init__(self):
        rospy.logwarn("Initializing")
             
        self.global_frame = self.load_param('~/global_frame')

        self._tfBuffer = tf2.Buffer()
        self._listener = tf2.TransformListener(self._tfBuffer)

        self._sub = rospy.Subscriber(self.load_param('~/person_positions'), PersonPositions, self.callback_images, queue_size=1)
        self._point_pub = rospy.Publisher("/rgbd_person_position", PointStamped, queue_size = 2)
        
        rospy.loginfo("PersonPublisher Initialized")

    def publish_rviz_marker(self, xyz):
        marker = Marker()

        marker.header.frame_id = self.global_frame
        marker.header.stamp = rospy.Time.now()

        # set shape, Arrow: 0; Cube: 1 ; Sphere: 2 ; Cylinder: 3
        marker.type = 3
        marker.id = 0

        # Set the scale of the marker
        marker.scale.x = 0.5
        marker.scale.y = 0.5
        marker.scale.z = 2.0

        # Set the color
        marker.color.r = 1.0
        marker.color.g = 0.0
        marker.color.b = 0.0
        marker.color.a = 1.0

        # Set the pose of the marker
        marker.pose.position.x = xyz[0]
        marker.pose.position.y = xyz[1]
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0

        self._marker_pub.publish(marker)

    def publish_point_msg(self, xyz, tstamp):
        point = PointStamped()
        point.header.stamp = tstamp
        point.header.frame_id = self.global_frame
        point.point.x = xyz[0]
        point.point.y = xyz[1] 
        point.point.z = 0

        self._point_pub.publish(point)

    # def callback_images(self, vicon_msg, tracking_msg):
    def callback_images(self, tracking_msg):
        # rospy.loginfo("callback_images")
        # print("callback_images")
        try:
            world_T_head = msg_to_se3(self._tfBuffer.lookup_transform(self.global_frame, 'head_rgbd_sensor_rgb_frame', tracking_msg.header.stamp))
                        
            transforms = {}
            dists = []


            num_people_detected = len(tracking_msg.positions)
            # print("Number of positions found {0}".format(num_people_detected))
            # For each person found in ther image
            if num_people_detected > 0:
                for i in range(num_people_detected):
                    pos = tracking_msg.positions[i]
                    if pos.z > 0.1:

                        head_T_person = np.eye(4)
                        head_T_person[0:3,3] = [pos.x, pos.y, pos.z]

                        world_T_person = np.dot(world_T_head, head_T_person)
                        # dists.append(np.linalg.norm(vicon_person[0:3,3] - world_T_person[0:3,3]))
                        transforms[i] = world_T_person
                        # print("x: {0}, y: {1}".format(world_T_person[0,3], world_T_person[1,3]))

                        # Since we aren't tracking people, remove those outside arena
                        if (world_T_person[0,3] < 4.0) and (world_T_person[1,3] < 1.7):
                            self.publish_point_msg(world_T_person[0:3,3], tracking_msg.header.stamp)

                # best_ind = np.argmin(np.array(dists))    
                # self.publish_rviz_marker(transforms[best_ind][0:3,3])
                # print(transforms[best_ind][0:3,3] - )
                # print("Error: {0}m".format(dists[best_ind]))


                # self.publish_rviz_marker(transforms[0][0:3,3])
                # self.publish_point_msg(transforms[0][0:3,3])

        except Exception as e:
            print(e)

    @staticmethod
    def load_param(param, default=None):
        new_param = rospy.get_param(param, default)
        rospy.loginfo("[PersonPublisher] %s: %s", param, new_param)
        return new_param

def main(argv):
    rospy.init_node('person_publisher_node')
    node = PersonPublisher()
    rospy.spin()

if __name__ == '__main__':
    main(sys.argv)
