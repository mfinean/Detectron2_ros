#!/usr/bin/env python2.7
import sys
import threading
import time

import cv2 as cv
import numpy as np
import rospy
import tf2_ros as tf2

from visualization_msgs.msg import Marker
from geometry_msgs.msg import TransformStamped
import tf.transformations as transformations


from geometry_msgs.msg import Point
from geometry_msgs.msg import Pose
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import Quaternion
from geometry_msgs.msg import Transform
from geometry_msgs.msg import TransformStamped
from geometry_msgs.msg import Vector3

from detectron2_ros.msg import PersonPositions, PersonPosition

# For sync depth and rgb
import message_filters


def pose_to_pq(msg):
    """Convert a C{geometry_msgs/Pose} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    p = np.array([msg.position.x, msg.position.y, msg.position.z])
    q = np.array([msg.orientation.x, msg.orientation.y,
                  msg.orientation.z, msg.orientation.w])
    return p, q


def pose_stamped_to_pq(msg):
    """Convert a C{geometry_msgs/PoseStamped} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    return pose_to_pq(msg.pose)


def transform_to_pq(msg):
    """Convert a C{geometry_msgs/Transform} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    p = np.array([msg.translation.x, msg.translation.y, msg.translation.z])
    q = np.array([msg.rotation.x, msg.rotation.y,
                  msg.rotation.z, msg.rotation.w])
    return p, q


def transform_stamped_to_pq(msg):
    """Convert a C{geometry_msgs/TransformStamped} into position/quaternion np arrays

    @param msg: ROS message to be converted
    @return:
      - p: position as a np.array
      - q: quaternion as a numpy array (order = [x,y,z,w])
    """
    return transform_to_pq(msg.transform)


def msg_to_se3(msg):
    """Conversion from geometric ROS messages into SE(3)

    @param msg: Message to transform. Acceptable types - C{geometry_msgs/Pose}, C{geometry_msgs/PoseStamped},
    C{geometry_msgs/Transform}, or C{geometry_msgs/TransformStamped}
    @return: a 4x4 SE(3) matrix as a numpy array
    @note: Throws TypeError if we receive an incorrect type.
    """
    if isinstance(msg, Pose):
        p, q = pose_to_pq(msg)
    elif isinstance(msg, PoseStamped):
        p, q = pose_stamped_to_pq(msg)
    elif isinstance(msg, Transform):
        p, q = transform_to_pq(msg)
    elif isinstance(msg, TransformStamped):
        p, q = transform_stamped_to_pq(msg)
    else:
        raise TypeError("Invalid type for conversion to SE(3)")
    norm = np.linalg.norm(q)
    if np.abs(norm - 1.0) > 1e-3:
        raise ValueError(
            "Received un-normalized quaternion (q = {0:s} ||q|| = {1:3.6f})".format(
                str(q), np.linalg.norm(q)))
    elif np.abs(norm - 1.0) > 1e-6:
        q = q / norm
    g = transformations.quaternion_matrix(q)
    g[0:3, -1] = p
    return g

class PersonViconPublisher(object):
    def __init__(self):
        rospy.logwarn("Initializing")
             
        self._vicon_sub = message_filters.Subscriber(self.load_param('~vicon_person'), TransformStamped)
        self._tracking_sub = message_filters.Subscriber(self.load_param('~person_tracking'), PersonPositions)
    
        self._tfBuffer = tf2.Buffer()
        self._listener = tf2.TransformListener(self._tfBuffer)

        self.ts = message_filters.ApproximateTimeSynchronizer([self._vicon_sub, self._tracking_sub], 1, 0.20) 
        self.ts.registerCallback(self.callback_images)

        self._marker_pub = rospy.Publisher("/visualization_marker", Marker, queue_size = 2)
        rospy.loginfo("PersonViconPublisher Initialized")

    def publish_rviz_marker(self, xyz):
        marker = Marker()

        marker.header.frame_id = "/vicon/world"
        marker.header.stamp = rospy.Time.now()

        # set shape, Arrow: 0; Cube: 1 ; Sphere: 2 ; Cylinder: 3
        marker.type = 3
        marker.id = 0

        # Set the scale of the marker
        marker.scale.x = 0.5
        marker.scale.y = 0.5
        marker.scale.z = 2.0

        # Set the color
        marker.color.r = 1.0
        marker.color.g = 0.0
        marker.color.b = 0.0
        marker.color.a = 1.0

        # Set the pose of the marker
        marker.pose.position.x = xyz[0]
        marker.pose.position.y = xyz[1]
        marker.pose.position.z = 0
        marker.pose.orientation.x = 0.0
        marker.pose.orientation.y = 0.0
        marker.pose.orientation.z = 0.0
        marker.pose.orientation.w = 1.0

        self._marker_pub.publish(marker)

    def callback_images(self, vicon_msg, tracking_msg):
        rospy.loginfo("callback_images")
        try:

            vicon_person = msg_to_se3(vicon_msg)
            
            # trans = self._tfBuffer.lookup_transform('vicon/world', 'head_rgbd_sensor_rgb_frame', vicon_msg.header.stamp)
            world_T_head = msg_to_se3(self._tfBuffer.lookup_transform('vicon/world', 'head_rgbd_sensor_rgb_frame', rospy.Time()))
            
            transforms = {}
            dists = []


            num_people_detected = len(tracking_msg.positions)
            print("Number of positions found {0}".format(num_people_detected))
            # For each person found in ther image
            if num_people_detected > 0:
                for i in range(num_people_detected):
                    pos = tracking_msg.positions[i]
                    head_T_person = np.eye(4)
                    head_T_person[0:3,3] = [pos.x, pos.y, pos.z]

                    world_T_person = np.dot(world_T_head, head_T_person)
                    dists.append(np.linalg.norm(vicon_person[0:3,3] - world_T_person[0:3,3]))
                    transforms[i] = world_T_person

                best_ind = np.argmin(np.array(dists))    
                self.publish_rviz_marker(transforms[best_ind][0:3,3])
                # print(transforms[best_ind][0:3,3] - )
                print("Error: {0}m".format(dists[best_ind]))
        except Exception as e:
            print(e)

    @staticmethod
    def load_param(param, default=None):
        new_param = rospy.get_param(param, default)
        rospy.loginfo("[PersonViconPublisher] %s: %s", param, new_param)
        return new_param

def main(argv):
    rospy.init_node('vicon_person_node')
    node = PersonViconPublisher()
    rospy.spin()

if __name__ == '__main__':
    main(sys.argv)
